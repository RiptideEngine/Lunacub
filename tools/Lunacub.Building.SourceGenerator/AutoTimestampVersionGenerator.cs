using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Text;

namespace Lunacub.Building.SourceGenerator;

[Generator(LanguageNames.CSharp)]
public sealed class AutoTimestampVersionGenerator : IIncrementalGenerator {
    public void Initialize(IncrementalGeneratorInitializationContext context) {
        var provider = context.SyntaxProvider.ForAttributeWithMetadataName(
            "Caxivitual.Lunacub.Building.Attributes.AutoTimestampVersionAttribute",
            Filter,
            Transform
        ).Where(x => x != null).Collect();
        
        context.RegisterSourceOutput(provider, Execute);
    }

    private static bool Filter(SyntaxNode node, CancellationToken token) {
        return node is ClassDeclarationSyntax;
    }

    private static GenerateTarget? Transform(GeneratorAttributeSyntaxContext context, CancellationToken token) {
        var typedSymbol = (INamedTypeSymbol)context.TargetSymbol;
                
        if (!IsTypeQualified((ClassDeclarationSyntax)context.TargetNode, typedSymbol, context.SemanticModel)) return null;

        ImmutableArray<INamedTypeSymbol> containingTypes = CollectContainingTypes(typedSymbol);
        
        AttributeData data = context.Attributes.First(x =>
            x.AttributeClass!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::Caxivitual.Lunacub.Building.Attributes.AutoTimestampVersionAttribute");

        if (data.ConstructorArguments[0].Value is not string format) return null;

        return new(typedSymbol.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat), containingTypes, typedSymbol, format);
    }

    private static void Execute(SourceProductionContext context, ImmutableArray<GenerateTarget?> targets) {
        StringBuilder sb = new StringBuilder("// <auto-generated/>").AppendLine().AppendLine();
        DateTime now = DateTime.Now;

        foreach (var nullableTarget in targets) {
            var target = nullableTarget!.Value;

            int revertLength = sb.Length;

            int indent = 0;
            if (!string.IsNullOrEmpty(target.Namespace)) {
                sb.Append("namespace ").Append(target.Namespace).AppendLine(" {");
                indent += 4;
            }

            // sb.Append(' ', indent).Append("partial ");
            for (int i = target.ContainingTypes.Length - 1; i >= 0; i--) {
                INamedTypeSymbol containingType = target.ContainingTypes[i];
                sb.Append(' ', indent).Append("partial ");
                
                switch (containingType.TypeKind) {
                    case TypeKind.Class: sb.Append("class "); break;
                    case TypeKind.Interface: sb.Append("interface "); break;
                    case TypeKind.Struct: sb.Append("struct "); break;
                    default:
                        sb.Length = revertLength;
                        sb.Append("Unknown containing type kind ").Append(containingType.TypeKind).AppendLine();
                        continue;
                }

                sb.Append(containingType.Name).AppendLine(" {");
                indent += 4;
            }

            sb.Append(' ', indent).Append("partial class ").Append(target.Symbol.Name).AppendLine(" {");
            indent += 4;
            {
                // sb.Append(' ', indent).Append('[').AppendLine("System.CodeDom.Compiler.GeneratedCode()]");
                sb.Append(' ', indent).Append("public override string Version => \"").Append(now.ToString(target.Format)).AppendLine("\";");
            }
            indent -= 4;
            sb.Append(' ', indent).AppendLine("}");

            for (int i = 0; i < target.ContainingTypes.Length; i++) {
                indent -= 4;
                sb.Append(' ', indent).AppendLine("}");
            }

            if (!string.IsNullOrEmpty(target.Namespace)) {
                sb.AppendLine("}");
                sb.AppendLine();
            }
        }
        
        context.AddSource("AutoTimestampVersion.g.cs", sb.ToString());
    }

    private static bool IsTypeQualified(ClassDeclarationSyntax node, INamedTypeSymbol symbol, SemanticModel semanticModel) {
        if (!InheritRequiredTypes(symbol.BaseType)) return false;
        
        foreach (var property in node.ChildNodes().OfType<PropertyDeclarationSyntax>()) {
            if (property.Identifier.ToString() == "Version") return false;
        }

        return true;

        static bool InheritRequiredTypes(INamedTypeSymbol? symbol) {
            while (true) {
                if (symbol == null) return false;

                if (symbol.ToDisplayString() is "Caxivitual.Lunacub.Building.Importer" or "Caxivitual.Lunacub.Building.Processor") {
                    return true;
                }

                symbol = symbol.BaseType;
            }
        }
    }

    private static ImmutableArray<INamedTypeSymbol> CollectContainingTypes(INamedTypeSymbol typeSymbol) {
        if (typeSymbol.ContainingType is not { } containingType) return ImmutableArray<INamedTypeSymbol>.Empty;

        var builder = ImmutableArray.CreateBuilder<INamedTypeSymbol>();

        while (true) {
            builder.Add(containingType);
            containingType = containingType.ContainingType!;

            if (containingType == null!) return builder.ToImmutable();
        }
    }

    public readonly struct GenerateTarget {
        public readonly string Namespace;
        public readonly ImmutableArray<INamedTypeSymbol> ContainingTypes;
        public readonly INamedTypeSymbol Symbol;
        public readonly string Format;

        public GenerateTarget(string @namespace, ImmutableArray<INamedTypeSymbol> containingTypes, INamedTypeSymbol symbol, string format) {
            Namespace = @namespace;
            ContainingTypes = containingTypes;
            Symbol = symbol;
            Format = format;
        }
    }
}